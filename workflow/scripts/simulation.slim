initialize() {
	initializeMutationRate(mu);
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", h, "f", 0.0); // introduced mutation
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 1000000);
	initializeRecombinationRate(R);
}

1 early() {
	// save this run's identifier, used to save and restore
	defineConstant("simID", getSeed());

	// create subpopulation
	sim.addSubpop("p1", asInteger(N));

	// set selfing rate
	p1.setSelfingRate(sigma);

	// generate schedule for beneficial mutations
	gens = cumSum(rpois(asInteger(n), lambda)); // make a vector of start gens

	gens = gens + (10*asInteger(N) - min(gens)) + 1; // align to start after burning, plus one to avoid weird ordering

	cat(simID + ": "+ sim.cycle + " - GENERATIONS: " + paste(gens) + "\n");
	defineConstant("Z", max(gens)); // remember the last gen

	for (gen in gens){
		community.registerLateEvent(NULL, s1.source, gen, gen);
	}

	community.rescheduleScriptBlock(s1, 2000000, 2000000);

	// reschedule beneficial mutation to be introduced after burn-in
        community.rescheduleScriptBlock(s0, start=10*asInteger(N), end=10*asInteger(N));

	// reschedule checking of establishment for soft sweep mutation
        community.rescheduleScriptBlock(s2, start=10*asInteger(N), end=10*asInteger(N) + 100000);

	// reschedule checking of threshold for partial sweep mutation
        community.rescheduleScriptBlock(s3, start=10*asInteger(N), end=10*asInteger(N) + 100000);

	// reschedule checking of fixation until after beneficial mutation is introduced
        community.rescheduleScriptBlock(s4, start=10*asInteger(N), end=10*asInteger(N) + 100000);

	// set variable to track when beneficial mutation first fixes
	// need defineGlobal to have variable be visible in other scopes
	defineGlobal("fixTracker", 0);
}

early() {
	// Every 1000 generations, output the heterozygosity and number of mutations in the population
        if(sim.cycle % 1000 == 0){
                pi = calcHeterozygosity(p1.genomes);
                numMuts = size(sim.mutations);
                catn(simID + ": " + sim.cycle + " " + pi + " " + numMuts);
        }
}

// save state of simulation after burn-in
s0 1000000 late(){
	// save the state of the simulation
	cat(simID + ": " + sim.cycle + " - SAVING STATE\n");
	sim.outputFull(tempdir() + "slim_" + simID + ".txt");
}

// introduce the sweep mutation in middle of simulated region
s1 1000000 late() {
	cat(simID + ": " + sim.cycle +  " - INTRODUCING BENEFICIAL MUTATION\n");
	target = sample(p1.genomes, 1); 
	mut = sim.mutationsOfType(m2); 
	if (mut.size() > 0) {
		target.addMutations(mut);
	} 
	else {
		target.addNewDrawnMutation(m2, 10000);
	}
}

// check if beneficial mutation (currently neutral) is established yet
// once established, convert to beneficial mutation
s2 2000000 late() { 
	mut = sim.mutationsOfType(m2); 
	if (size(mut) == 1) { 
		if (sim.mutationFrequencies(NULL, mut) >= f0) { 
			cat(simID + ": " + sim.cycle + " - ESTABLISHED - CONVERTING TO BENEFICIAL\n"); 
			mut.setSelectionCoeff(sweepS); 
			//community.deregisterScriptBlock(self);
			community.rescheduleScriptBlock(self,1000000,1000000); 
		} 
	} 	
}


// check if mutation (currently beneficial) has reached threshold frequency
// once threshold is reached, convert beneficial mutation to neutral
s3 3000000 late() {
        mut = sim.mutationsOfType(m2);
        if (size(mut) == 1) {
                if (sim.mutationFrequencies(NULL, mut) >= f1) {
                        cat(simID + ": " + sim.cycle + " - THRESHOLD REACHED â€“ CONVERTING TO NEUTRAL\n");
                        mut.setSelectionCoeff(0.0);
                        //community.deregisterScriptBlock(self);
			community.rescheduleScriptBlock(self,1000000,1000000); 
                }
        }
}
 
// check for fixation of beneficial mutation
s4 4000000 late() {
	if (sim.countOfMutationsOfType(m2) == 0){
		fixed = (sum(sim.substitutions.mutationType == m2) == 1);

		if (fixed){
			// first generation that mutation fixed
			if (fixTracker == 0){
				cat(simID + ": " + sim.cycle + " - FIXED\n");
			}

			// stop some generations after fixation
			if (fixTracker == tau){
				cat(simID + ": " + sim.cycle + " - STOPPED\n");

				// random sample of individuals from simulation
				cat("Randomly sampling population...\n");
				g = p1.sampleIndividuals(128).genomes; 
 	
				// output sampled unphased genomes as VCF
				cat("Output sample as VCF...\n");
				g.outputVCF(filePath = "slim_" + asString(ID) + ".vcf", simplifyNucleotides=F, outputNonnucleotides=T);

				// output when sweep fixed
				cat("Outputing fixation time...\n");
				writeFile("fix_time_" + asString(ID) + ".txt", paste(sim.cycle - 10*asInteger(N), sep=""));

				cat("Simulation finished! :)\n");
				sim.simulationFinished();
			}

			// increment tracker of generations post-fixation
			fixTracker = fixTracker + 1;
		}

		else {
			if (sim.cycle > Z) {
				cat(simID + ": " + sim.cycle + " - SWEEP LOST - RESTARTING\n");
				// go back to tick before sweep introduced
				sim.readFromPopulationFile(tempdir() + "slim_" + simID + ".txt");

				// start a newly seeded run
				setSeed(rdunif(1, 0, asInteger(2^62) - 1));

				// re-register frequency checks for next cycle
				community.rescheduleScriptBlock(s2, start=sim.cycle + 1, end=10*asInteger(N) + 1000000);
				community.rescheduleScriptBlock(s3, start=sim.cycle + 1, end=10*asInteger(N) + 1000000);

			}
		}
	}
}
